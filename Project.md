## 项目 CMDB资源管理
1. 项目介绍
CMDB的意思是组织资源配置管理，CMDB的基本管理模型是按照(应用-子应用-组件-环境)树状结构进行构建
的，客户通过CMDB平台提供的资源拓扑树对自己购买的云资源如弹性云服务器ECS、对象存储OBS、云数据库
RDS等进行分类、快捷、高效地管理和查找；除此之外CMDB资源拓扑树还是应用监控和告警等服务的基础组
件。


2. 项目难点
+ 基于业务驱动的内源组件Ti-Tree的二次开发
+ 树组件需要实现记忆功能 (ES6 Map => LocalStorage 二次封装)
+ 树组件节点的精准定位(EventBus同页面跨组件实现 其他页面跳转路由传参)
+ 基于不同团队树节点过滤功能(比如APM监控团队需要展示环境节点 Uni-Agent需要展示组件和环境节点)
+ 为项目组节省2人/月的开发人力 
+ 树组件事件对象二次封装和派发
+ 需求收集-二次开发-测试流水线-发布内源npm二方组件库
+ 将树组件独立为npm包进行发布，从业务逻辑中完全解耦出来，提高后续维护和迭代开发效率


## 天天车宝 APP 移动端
+ 解决团队内部比较棘手的汽车行驶路线绘制偏移的问题(发现问题-查找问题-找到根本原因-尝试-解决问题)
+ 基于国内常见的三种地图坐标系之间的规则 封装地图坐标系转化gps-transform.js
+ 配置项目browserslist目标浏览器列表结合PostCSS插件Autoprefixer实现CSS代码的自动前缀补足 不用再写-webkit-的语法了
+ 性能优化 解决快速切换页面时取消失活页面网路请求的问题 减少网络消耗
+ 移动端不分页 对汽车行驶数据如坐标点、油耗、告警等列表采用虚拟滚动(如何实现的)的方式实现 减少渲染压力

## 车管家后台管理系统 后台管理系统
+ axios 网络请求高度封装
+ 权限系统的设计与实现，如登录权限、页面权限、菜单权限及按钮权限
+ 购买车保险所需文件及资料打包上传 大文件切片上传和断点续传的实现
+ webpack打包优化 具体优化了那些点 是如何优化的
+ 基于webpack.reuire自动生成vuex中modules配置 以一种可预期配置的方式实现模块注入
+ 基于异步组件实现路由懒加载过程中的Loading效果


为了方便管理项目方上币及市场管理等，将项目方后台从官网后台进行分离，建立独立的项目方后台管理系统。提供项目方市场管理、资产管理、配置管理和数据统计等功能，让项目方能独立进行账户管理。

为项目方提供市场、资产、资讯、统计以及个性化配置导航，实现信息查看、修改、编辑全功能。
项目方资产收益统一管理，数据Echat可视化呈现，清晰明了。

1、资产统一管理

2、收益记录，按月结算

3、委托、交易、充提记录管理

2、实时发布官方公告，统一信息管理

3、统一后台视觉，界面扁平化设计


## 后台管理系统项目 4个难点
1. axios的高度封装(集合react的axios)
    取消请求
    自定义实例
    队列保存
    错误判断
    404
    
2. 权限设计
    比如组件级别
    比如按钮级别
    比如页面级别

3. 数据持久化
    如何做数据持久化

4. 大文件上传
    切片上传
    断点续传

5. webpack优化

6. 首屏渲染如何优化

7. 深挖webpack中的点

## 移动端响应式适配怎么做？
响应式的核心就是随着用户终端设备屏幕尺寸的变化，页面上的元素可以动态的自适应的增大或者缩小，为用户带来良好的使用体验，目的是为了增强用户体验

实现手段很多：
lib-flexible 用于动态计算根html的字体 前提是你在项目中用了rem
每一个盒子都写rem，因为需要我们自己算，这很不爽，所以我们又用了px2rem插件
我们写在代码中的还是px，比如375px大小的设计稿上标注为100px的盒子，我们开发的时候还是写100px
通过这个插件 他会自动将100px转化为对应的rem在浏览器的控制台展示
而rem又是动态变化的 这样既实现需求 又利于开发

100px => px2rem rootValue = 37.5 => 2.66667rem => lib-flexible => root fonsize 37.5px => 实现盒子渲染大小


1. 用到了哪些插件
2. lib-flexible的核心原理及实现 为什么要一开始导入 有个文章讲这个 我必须会
3. meta标签是干什么用的
4. B站的那个视频 https://www.bilibili.com/video/BV1YT411f7Qe/?spm_id_from=333.999.header_right.history_list.click&vd_source=14e5cd2a541abada387db401c3a21cff

请注意 lib-flexible这个库的作用只是基于读取用户设备宽度device-width来动态计算出根html标签的font-size是多少像素
当我们在项目中使用了rem单位的时候，实际宽度是动态变化的，举个例子：

有一个div，宽度为10rem
那么它在iphone6中lib-flexible这个库计算出来根字体大小为37.5px 所以在这个手机上盒子就宽375px 占满屏幕
那么它在iphone8中lib-flexible这个库计算出来根字体大小为41.4px 所以在这个手机上盒子就宽414px 占满屏幕

如果没有这个lib-flexible库，而我们机械的写死根html的字体大小为37.5px的话
上面就会变成：
在iphone6中宽度为375px 占满
在iphone8中宽度还是375px 就占不满 就不符合响应式的要求


## 转化规则
核心的几个参数：
1. 基准设计稿宽度为375px
2. flexible计算出来的根字体大小就是37.5px
3. 设置px2rem插件的配置 rootValue为37.5
4. 设计稿上100px的盒子 代码中写100px 会被转化为 100 / 37.5 = 2.667rem 实际渲染还是100px 占页面的比例大约三分之一
5. 用户切换了设备 打包后的代码已经固定了就是2.667rem 变化的是flexible计算出来的根字体大小就是41.4px 实际渲染就变为了110px 占页面的比例还是大约三分之一
6. 用户感知的一定是比例 不会感知像素 这说明响应式就成了
7. 以上这一套都是uni-app自带的
8. 最后注意一点 你设置的rootValue为37.5是多少 你写代码的时候就按照设计稿375px去写

如何设计稿宽度为750px，有一个占一半宽的盒子  375px
代码中写375px
rem = 37.5px

rootValue = 37.5
浏览器计算出来会是 375px /rootValue = 10rem
实际渲染到页面上就是10rem * 37.5px = 375px 会把iphone6占满了 这不对

1. 要不我们代码中写的时候自己计算除以2 也就是写187.5px / rootVALUE = 5rem
实际渲染就是5rem * 37.5px = 187.5px 刚好把iphone6占一半
在iphone8上 rem = 41.4 5rem * 41.4px = 207px 刚好把iphone8占一半

2. 要不我们就配置插件的时候增大rootValue为75
写代码的时候还是写375px / rootValue = 5rem
这样子也可以

总的来说两个思路：
1. 如果是375，就配置rootValue为37.5，自己写代码的时候设计稿是多少就写多少
2. 如果是750，就配置rootValue为75，自己写代码的时候设计稿是多少就写多少

如果统一配rootValue为37.5，那么就需要在写代码的时候自己计算，是缩小1倍还是扩大1倍 还是配置插件划来
